#!/usr/bin/env python

import sys
import re
import subprocess
import os
import shutil
import datetime

from stat import *

class SaruBaseError(Exception):
  """Base Class for handling non-test-failure errors in saru"""
  def __init__( self, mesg ):
    self.mesg = mesg

class SaruTestResult:
  """Whether a test passes or fails and any other available information"""
  def __init__(self, testname, passed, mesg, stdout, stderr):
     self.testname = testname
     self.passed = passed
     self.mesg = mesg
     self.stdout = stdout
     self.stderr = stderr

class SaruPaths:
  """Class that contains the required paths"""
  def __init__( self, callingScriptPath ):
    # How was this script run?
    self.sarubinpath = os.path.dirname( os.path.abspath( callingScriptPath  ) )
    self.saruparse = os.path.normpath( self.sarubinpath + "/saru-parse" )
    self.saruruntest = os.path.normpath( self.sarubinpath + "/saru-run-test" )
    self.sarusearch = os.path.normpath( self.sarubinpath + "/saru-search" )

class SingleTestRunner:
  """Runs a single test"""
  def __init__(self, fulltestname ):
    self.fulltestname = fulltestname
    (self.testdir, self.testname) = os.path.split( self.fulltestname )
    if(self.testdir==""):
      self.testdir="."
    self.dotsaru =  os.path.normpath( self.testdir + "/.saru" )

  def getSettings( self ):
    """Parses the output of "saru-parse dump" run on the test file an returns it as a dictionary"""
    parseProcess = subprocess.Popen([ sarupath.saruparse, "dump", self.fulltestname], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    retcode = parseProcess.wait()
    if(retcode!=0):
      raise SaruBaseError( "saru-parse failed with error code " + repr(retcode) + "\n" +  parseProcess.communicate()[1] )

    settings = parseProcess.communicate()[0]
    filesettings = {};
    for confline in settings.splitlines():
      kv = confline.split( ":", 1)
      if len( kv )==2:
        key = kv[0].strip()
        value = kv[1].strip()
        if key in filesettings:
          filesettings[ key ].append( value )
        else:
          filesettings[ key ] = [ value ]
    return filesettings

  # Returns a list of 
  # [ SaruTestResult x N ] otherwise 
  #  raises SaruBaseError on error
  def run(self):
    """Actually run the test"""
    if ( os.path.isdir( self.fulltestname ) ):
      raise SaruBaseError( "Doesn't run on a directory yet." )

    if( not os.path.exists( self.fulltestname ) ):
      raise SaruBaseError( "nonexistant test "+ os.path.basename( self.fulltestname ) )

    isSaruStatus = isSaru( self.fulltestname )
    if( not isSaruStatus[0] ):
      if( isSaruStatus[1] == "NO"):
        raise SaruBaseError( "file does not contain any saru test information" )
      elif ( isSaruStatus[1] == "UNKNOWN FORMAT"):
        raise SaruBaseError( "file is of unknown format" )
      else:
        raise SaruBaseError( "unknown status code \""+isSaruStatus[1] +"\" from saru-parse issaru" )

    try:
      filesettings = self.getSettings()
    except SaruBaseError, e:
      raise SaruBaseError( e.mesg )

    if ( not os.path.isdir( self.dotsaru ) ):
      if( os.path.exists( self.dotsaru ) ):
        raise SaruBaseError( ".saru object exists but is not directory!" )
      os.mkdir( self.dotsaru )

    if ( not os.path.isdir( self.dotsaru+"/bin" ) ):
      if( os.path.exists( self.dotsaru+"/bin" ) ):
        raise SaruBaseError( ".saru/bin object exists but is not directory!" )
      os.mkdir( self.dotsaru+"/bin" )

    extension = os.path.splitext(self.testname)[1]
    if(extension==".cpp"):
    #CPP Files get compiled via a makefile
      makefilename = os.path.normpath( self.dotsaru+"/"+self.testname+".make" )
      makefile = open( makefilename,"w")

      # BUILD A MAKE FILE...
      # TODO Make these use the settings taht got read in from the saru-parse stage
      print >> makefile, "INCLUDES=\n"
      print >> makefile, "EXTRAOBJECTS=\n"
      print >> makefile, "CXXFLAGS=\n"
      
      includeRegExp = re.compile(r"\s*CxxInclude\s*:\s*(.*)$")
      extraObjsRegExp = re.compile(r"\s*CxxExtraObjects\s*:\s*(.*)$")
      cxxFlagsRegExp = re.compile(r"\s*CxxFlags\s*:\s*(.*)$")

      if "CxxInclude" in filesettings:
        for incdir in " ".join(filesettings["CxxInclude"]).split():
          print >> makefile, "INCLUDES+= -I"+incdir+"\n"
      if "CxxExtraObjects" in filesettings:
        for obj in " ".join(filesettings["CxxExtraObjects"]).split():
          print >> makefile, "EXTRAOBJECTS+= "+obj+"\n"
      if "CxxFlags" in filesettings:
        for flags in filesettings["CxxFlags"]:
          print >> makefile, "CXXFLAGS+= "+flags+"\n"
      
      print >> makefile, self.testname + ".test : " + self.testname
      print >> makefile, "\tg++ $(CXXFLAGS) " + self.testname + " -o .saru/bin/" + self.testname + ".test $(INCLUDES) $(EXTRAOBJECTS)"
      makefile.close()
      
      # Lets try making it...
      # TODO Make these use the settings taht got read in from the saru-parse stage
      makeProcess = subprocess.Popen(["/usr/bin/make", "-C", self.testdir, "--file", makefilename], stdout=subprocess.PIPE, stderr=subprocess.PIPE  )
      retcode=makeProcess.wait()
      
      if(retcode!=0):
        make_stdout, make_stderr = makeProcess.communicate()
        return [ SaruTestResult( self.testname, False, "saru-run-test : make failed with error code " + repr(retcode), make_stdout, make_stderr ) ]
      executablename = os.path.normpath(self.dotsaru+"/bin/"+self.testname+".test")
    elif(extension==".py"):
      executablename = os.path.normpath( self.dotsaru+"/bin/"+self.testname )
      shutil.copyfile( self.fulltestname, executablename) 
    elif(extension==".bash"):
      executablename = os.path.normpath( self.dotsaru+"/bin/"+self.testname )
      shutil.copyfile( self.fulltestname, executablename) 
    else:
      print >> sys.stderr, "Unknown extension on file "+self.testname
      exit(1)

    # Lets try running it...
    os.chmod( executablename, S_IREAD | S_IWUSR | S_IXUSR )
    testProcess = subprocess.Popen([ executablename ], stdout=subprocess.PIPE, stderr=subprocess.PIPE ) 
    retcode=testProcess.wait()

  #TODO: Why is this printing to stdout rather than stderr
    test_stdout, test_stderr = testProcess.communicate()
    if(retcode!=0):
      return [ SaruTestResult( self.testname, False, "saru-run-test : execution of test failed with error code " + repr(retcode), test_stdout, test_stderr ) ]

    return [ SaruTestResult( self.testname, True, "OK", test_stdout, test_stderr ) ]

sarupath = SaruPaths(sys.argv[0])

def printUsage():
  print "USAGE: saru-run-test single <filename>"
  print "USAGE: saru-run-test suite <dirname>"
  print "USAGE: saru-run-test tag <tagname> <dirname>"

# saru-parse issaru xxxx .. what does it return?
# General failure retcode = 1
# Unsupported format retcode = 0, stdout = "UNKNOWN FORMAT"
# supported format without saru info retcode = 0, stdout="NO"
# supported format with saru info retcode = 0, stdout="YES"
#
def isSaru(fulltestname):
  checkProcess = subprocess.Popen([ sarupath.saruparse, "issaru", fulltestname], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  retcode = checkProcess.wait()
  if(retcode!=0):
    print "saru-run-test : saru-parse issaru check died with error code " + repr(retcode)
    print checkProcess.communicate()[1]
    exit(1)
  retcode = checkProcess.communicate()[0].splitlines()[0] 
  return ( (( retcode != "NO" ) and ( retcode != "UNKNOWN FORMAT")), retcode )

def runSingleTest():
  if ( len(sys.argv) != 3 ):
    printUsage()
    exit(1)
  s = SingleTestRunner( sys.argv[2] )
  try:
    result = s.run()
  except SaruBaseError, e:
    print >> sys.stderr, os.path.basename( sys.argv[0] ) +" : " + e.mesg
    exit(1)
  for t in result:
    if not t.passed:
      print >> sys.stderr, t.mesg
      print >> sys.stderr, t.stderr
      print >> sys.stderr, t.stdout
      exit(1)
    else:
      print "OK"
      exit(0)

def runSuiteOfTests():
  if len(sys.argv)!=3:
    print >> sys.stderr, "saru-run-test : suite mode expects one additional argument"
    exit(1)
  suitepath = sys.argv[2]
  if ( not os.path.isdir(suitepath ) ):
    print >> sys.stderr, os.path.basename( sys.argv[0] )+" : requires a directory name."
    exit(1)
  filelist = os.listdir(suitepath)
  filelist.sort()
  filelist = [ os.path.normpath(suitepath+"/"+x) for x in filelist ] 
  filelist = [ x for x in filelist if os.path.isfile(x) ]
  filelist = [ x for x in filelist if isSaru(x)[0] ]
  passcount = 0
  for f in filelist:
    print os.path.basename(f) + " :",
  
    runProcess = subprocess.Popen([ sarupath.saruruntest, "single", f], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    retcode = runProcess.wait()
    if(retcode!=0):
      (runstdout,runstderr) = runProcess.communicate()
      if(runstderr.strip()=="saru-run-test : execution of test failed with error code 1"):
        print "FAILED"
      else:
        print "FAILED???"
        print "  STDOUT :" + runstdout
        print "  STDERR :" + runstderr 
    else:
      (runstdout,runstderr) = runProcess.communicate()
      if(runstdout=="OK\n"):
        print "OK"
        passcount = passcount + 1
      else:
        print "???"
        print "  STDOUT :" + runstdout
        print "  STDERR :" + runstderr 
  
#  (dirpath, dirnames, filenames ) = os.walk(sys.argv[2])
#  print dirpath
#  print dirnames
#  print filenames
  print repr(passcount) + " / " + repr( len(filelist) )
  try:
    f = open( os.path.normpath(suitepath+"/saru.progress" ), "a" )
    print >> f, datetime.datetime.now().isoformat(),
    print >> f, " "+str(passcount)+" "+str( len(filelist) )
  except IOError:
    print "Unable to write results to log file"

  if( passcount == len(filelist) ):
    exit(0)
  exit(1)

def runTaggedTests():
  tagname = sys.argv[2]
  tagpath = sys.argv[3]
  if ( not os.path.isdir(tagpath ) ):
    print >> sys.stderr, os.path.basename( sys.argv[0] )+" : requires a directory name."
    exit(1)

  tagProcess = subprocess.Popen( [ sarupath.sarusearch, "tag", tagname, tagpath ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  retcode = tagProcess.wait()
  (tagstdout,tagstderr) = tagProcess.communicate()
  if(retcode!=0):
    print "saru-run-test : saru-search failed with value " + repr(recode)
    print "  STDOUT :" + tagstdout
    print "  STDERR :" + tagstderr 
  
  filelist = tagstdout .splitlines()
  filelist = [ os.path.normpath(tagpath+"/"+x) for x in filelist ] 

  passcount = 0
  for f in filelist:
    print os.path.basename(f) + " :",
  
    runProcess = subprocess.Popen([ sarupath.saruruntest, "single", f], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    retcode = runProcess.wait()
    if(retcode!=0):
      (runstdout,runstderr) = runProcess.communicate()
      if(runstdout=="saru-run-test : execution of test failed with error code 1\n"):
        print "FAILED"
      else:
        print "FAILED???"
        print "  STDOUT :" + runstdout
        print "  STDERR :" + runstderr 
    else:
      (runstdout,runstderr) = runProcess.communicate()
      if(runstdout=="OK\n"):
        print "OK"
        passcount = passcount + 1
      else:
        print "???"
        print "  STDOUT :" + runstdout
        print "  STDERR :" + runstderr 
  
#  (dirpath, dirnames, filenames ) = os.walk(sys.argv[2])
#  print dirpath
#  print dirnames
#  print filenames
  print repr(passcount) + " / " + repr( len(filelist) )
  if( passcount == len(filelist) ):
    exit(0)
  exit(1)


if (len(sys.argv) < 2):
  printUsage()
  exit(1) 


if ( sys.argv[1] == "single" ):
  runSingleTest()
elif ( sys.argv[1] == "suite" ):
  runSuiteOfTests()
elif (sys.argv[1] == "tag" ):
  runTaggedTests()

print >> sys.stderr,"saru-run-test : Unknown mode "+sys.argv[1]
printUsage()
exit(1) 



