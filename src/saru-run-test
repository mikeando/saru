#!/usr/bin/env python

# Copyright (c) 2008, Michael Anderson
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the saru library nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY MICHAEL ANDERSON ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL MICHAEL ANDERSON BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import sys
import re
import subprocess
import os
import shutil
import datetime
import glob
import time

from stat import *



class SaruBaseError(Exception):
  """Base Class for handling non-test-failure errors in saru"""
  def __init__( self, mesg ):
    self.mesg = mesg



# saru-parse issaru xxxx .. what does it return?
# General failure retcode = 1
# Unsupported format retcode = 0, stdout = "UNKNOWN FORMAT"
# supported format without saru info retcode = 0, stdout="NO"
# supported format with saru info retcode = 0, stdout="YES"
#
def isSaru(fulltestname):
  checkProcess = subprocess.Popen([ sarupath.saruparse, "issaru", fulltestname], stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
  (pstdout,pstderr) = checkProcess.communicate()
  retcode = checkProcess.returncode
  if(retcode!=0):
    print "saru-run-test : saru-parse issaru check died with error code " + repr(retcode)
    print pstderr
    exit(1)
  retcode = pstdout.splitlines()[0] 
  return ( (( retcode != "NO" ) and ( retcode != "UNKNOWN FORMAT")), retcode )



def checkValidFile( fulltestname ):
  """Check that the file specified exists, is not a directory, is a recognised format, and is tagged as a saru test"""
  if ( os.path.isdir( fulltestname ) ):
    raise SaruBaseError( "Doesn't run on a directory yet." )

  if( not os.path.exists( fulltestname ) ):
    raise SaruBaseError( "nonexistant test "+ os.path.basename( fulltestname ) )

  isSaruStatus = isSaru( fulltestname )
  if( not isSaruStatus[0] ):
    if( isSaruStatus[1] == "NO"):
      raise SaruBaseError( "file does not contain any saru test information" )
    elif ( isSaruStatus[1] == "UNKNOWN FORMAT"):
      raise SaruBaseError( "file is of unknown format" )
    else:
      raise SaruBaseError( "unknown status code \""+isSaruStatus[1] +"\" from saru-parse issaru" )



def checkDotSaru( dotsarupath ):
  """Make sure the .saru and .saru/bin directories exist. Raise a SaruBaseError if they dont."""
  if ( not os.path.isdir( dotsarupath ) ):
    if( os.path.exists( dotsarupath ) ):
      raise SaruBaseError( ".saru object exists but is not directory!" )
    os.mkdir( dotsarupath )

  if ( not os.path.isdir( dotsarupath+"/bin" ) ):
    if( os.path.exists( dotsarupath+"/bin" ) ):
      raise SaruBaseError( ".saru/bin object exists but is not directory!" )
    os.mkdir( dotsarupath+"/bin" )

def getSettings( fulltestname ):
  """Parses the output of "saru-parse dump" run on the test file an returns it as a dictionary"""
  parseProcess = subprocess.Popen([ sarupath.saruparse, "dump", fulltestname], stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
  (pstdout,pstderr) = parseProcess.communicate()
  retcode = parseProcess.returncode
  if(retcode!=0):
    raise SaruBaseError( "saru-parse failed with error code " + repr(retcode) + "\n" +  pstderr )

  settings = pstdout
  filesettings = {};
  for confline in settings.splitlines():
    kv = confline.split( ":", 1)
    if len( kv )==2:
      key = kv[0].strip()
      value = kv[1].strip()
      if key in filesettings:
        filesettings[ key ].append( value )
      else:
        filesettings[ key ] = [ value ]
  return filesettings


# A utililty function designed to read the output of a single test that supports multiple results.
# The output  should look something like
#  <@saru start test_replace_with_null @>
#  <@saru end test_replace_with_null @>
#  <@saru start test_event_mask @>
#      In function test_event_mask
#  scratch.cpp:250: saru_assert failed. : false
#  <@saru end test_event_mask @>
#And the result of parseSaruLogText should be {'test_replace+with_null':'', 'test_event_mask':'   In function ....' }

def parseSaruLogText( input ):
  results = {}
  matchSaruLogStart = re.compile(r'^\s*<@saru\s+(\w+)\s+([a-zA-Z0-9_:]+)\s+@>\s*$');

  curkey="@before";
  for l in input.splitlines():
    m =matchSaruLogStart.search(l) 
    if m:
      saruLogAction = m.group(1)
      saruLogTarget = m.group(2)
      if ( saruLogAction=="start" ) and ( curkey=="@before" or curkey=="@between" ) :
        curkey=saruLogTarget
        results[curkey]=""
      if ( saruLogAction=="end" ):
        curkey="@between"
      continue;
    if curkey in results:
      results[curkey]+=l+"\n";
    else:
      results[curkey]=l+"\n";
  return results


class SaruTestResult:
  """Whether a test passes or fails and any other available information"""
  def __init__(self, testname, passed, mesg, stdout, stderr):
     self.testname = testname
     self.passed = passed
     self.mesg = mesg
     self.stdout = stdout
     self.stderr = stderr



class SaruPaths:
  """Class that contains the required paths"""
  def __init__( self, callingScriptPath ):
    # How was this script run?
    self.sarubinpath = os.path.dirname( os.path.abspath( callingScriptPath  ) )
    self.saruparse = os.path.normpath( self.sarubinpath + "/saru-parse" )
    self.saruruntest = os.path.normpath( self.sarubinpath + "/saru-run-test" )
    self.sarusearch = os.path.normpath( self.sarubinpath + "/saru-search" )



class SingleTestRunner:
  """Runs a single test"""

  def __init__(self, fulltestname ):
    self.fulltestname = fulltestname
    (self.testdir, self.testname) = os.path.split( self.fulltestname )
    if(self.testdir==""):
      self.testdir="."
    self.dotsaru =  os.path.normpath( self.testdir + "/.saru" )

  # Returns a list of 
  # [ SaruTestResult x N ] otherwise 
  #  raises SaruBaseError on error
  def run(self):
    """Actually run the test"""
    try:
      checkValidFile( self.fulltestname )
      checkDotSaru( self.dotsaru )
      filesettings = getSettings(self.fulltestname)
    except SaruBaseError, e:
      return [ SaruTestResult( self.testname, False, "saru-run-test : "+e.mesg, "", "") ]

    extension = os.path.splitext(self.testname)[1]
    if(extension==".cpp"):
    #CPP Files get compiled via a makefile
      makefilename = os.path.normpath( self.dotsaru+"/"+self.testname+".make" )
      makefile = open( makefilename,"w")

      # BUILD A MAKE FILE...
      # TODO Make these use the settings taht got read in from the saru-parse stage
      print >> makefile, "INCLUDES=\n"
      print >> makefile, "EXTRAOBJECTS=\n"
      print >> makefile, "CXXFLAGS=\n"
      
      includeRegExp = re.compile(r"\s*CxxInclude\s*:\s*(.*)$")
      extraObjsRegExp = re.compile(r"\s*CxxExtraObjects\s*:\s*(.*)$")
      cxxFlagsRegExp = re.compile(r"\s*CxxFlags\s*:\s*(.*)$")

      if "CxxInclude" in filesettings:
        for incdir in " ".join(filesettings["CxxInclude"]).split():
          incdir = os.path.expandvars(incdir)
          print >> makefile, "INCLUDES+= -I"+incdir+"\n"
      if "CxxExtraObjects" in filesettings:
        for obj in " ".join(filesettings["CxxExtraObjects"]).split():
          print >> makefile, "EXTRAOBJECTS+= "+os.path.expandvars(obj)+"\n"
      if "CxxFlags" in filesettings:
        for flags in filesettings["CxxFlags"]:
          print >> makefile, "CXXFLAGS+= "+os.path.expandvars(flags)+"\n"
      if "CxxLibs" in filesettings:
        for libs in filesettings["CxxLibs"]:
          print >> makefile, "CXXLIBS+= "+os.path.expandvars(libs)+"\n"
      
      print >> makefile, self.testname + ".test : " + self.testname
      print >> makefile, "\tg++ $(CXXFLAGS) " + self.testname + " -o .saru/bin/" + self.testname + ".test $(INCLUDES) $(CXXLIBS) $(EXTRAOBJECTS)"
      makefile.close()
      
      # Lets try making it...
      # TODO Make these use the settings taht got read in from the saru-parse stage
      makeProcess = subprocess.Popen(["/usr/bin/make", "-C", self.testdir, "--file", ".saru/"+self.testname+".make"], stdout=subprocess.PIPE, stderr=subprocess.PIPE  , close_fds=True)
      (make_stdout,make_stderr) = makeProcess.communicate()
      retcode=makeProcess.returncode

      if(retcode!=0):
        return [ SaruTestResult( self.testname, False, "saru-run-test : make failed with error code " + repr(retcode), make_stdout, make_stderr ) ]
      executable = [ os.path.normpath(self.dotsaru+"/bin/"+self.testname+".test") ]
    elif(extension==".py"):
      executable = [ os.path.normpath( self.dotsaru+"/bin/"+self.testname ) ]
      shutil.copyfile( self.fulltestname, executable[0]) 
      os.chmod( executable[0], S_IREAD | S_IWUSR | S_IXUSR )
    elif(extension==".php"):
      executable = [ "php", os.path.normpath( self.dotsaru+"/bin/"+self.testname ) ]
      shutil.copyfile( self.fulltestname, executable[1]) 
    elif(extension==".bash"):
      executable = [ os.path.normpath( self.dotsaru+"/bin/"+self.testname ) ]
      shutil.copyfile( self.fulltestname, executable[0]) 
      os.chmod( executable[0], S_IREAD | S_IWUSR | S_IXUSR )
    elif(extension==".dummymt"):
      return [ SaruTestResult( self.testname+"::1", True, "true as dummy", "", "" ), SaruTestResult( self.testname+"::2", False, "false as dummy", "", "" ) ]
    else:
      print >> sys.stderr, "Unknown extension on file "+self.testname
      exit(1)

    # Lets try running it...
    testProcess = subprocess.Popen( executable, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True ) 

    test_stdout, test_stderr = testProcess.communicate()
    retcode=testProcess.returncode

#if test_stdlout looks like this then we can return all the tests.
#test_basics : OK
#test_alt : OK
#test_double_same : OK
#test_null : OK
#test_replace_with_null : OK
#test_event_mask : FAILED
#5 / 6

    #Lets try chunking up the stdout into "<@saru start ... @> to <@saru end ... @> blocks
    stderrchunks = parseSaruLogText( test_stderr );

    retval = [];
    matchOK = re.compile(r'^\s*([a-zA-Z0-9_:]+)\s*:\s*OK\s*$')
    matchFAILED = re.compile(r'^\s*([a-zA-Z0-9_:]+)\s*:\s*FAILED\s*$')
    matchResult = re.compile(r'^(\d+)\s*/\s*(\d+)\s*$')
    matchEmpty = re.compile(r'^\s*$')
    nPassed = 0
    nFailed = 0

    for l in test_stdout.splitlines():
      match = matchOK.search( l );
      if(match):
        retval.append( SaruTestResult( self.testname+"::"+match.group(1), True, "", "", stderrchunks[match.group(1)]) )
        nPassed = nPassed+1;
        continue
      match = matchFAILED.search( l );
      if(match):
        retval.append( SaruTestResult( self.testname+"::"+match.group(1), False, "", "", stderrchunks[match.group(1)]) )
        nFailed = nFailed+1;
        continue
      match = matchResult.search( l );
      if(match):
        if (nPassed==int(match.group(1))) and ((nPassed+nFailed)==int(match.group(2))) :
          return retval;
        return [ SaruTestResult( self.testname, False, "saru-run-test : Incorrect reporting on pass / fail count.\n"+match.group(1)+" / " +match.group(2)+" vs "+str(nPassed)+" / " +str(nPassed+nFailed), test_stdout, test_stderr ) ]
      match = matchEmpty.search( l );
      if(match):
        continue
      #Unexpected line .. output not in the nice multitest-saru format .. so break and fall back on old method.
      break

        
    if(retcode!=0):
      return [ SaruTestResult( self.testname, False, "saru-run-test : execution of test failed with error code " + repr(retcode), test_stdout, test_stderr ) ]

    return [ SaruTestResult( self.testname, True, "OK", test_stdout, test_stderr ) ]



sarupath = SaruPaths(sys.argv[0])



def printUsage():
  print "USAGE: saru-run-test single <filename>"
  print "USAGE: saru-run-test suite <dirname>"
  print "USAGE: saru-run-test tag <tagname> <dirname>"



def runSingleTest():
  if ( len(sys.argv) != 3 ):
    printUsage()
    exit(1)
  s = SingleTestRunner( sys.argv[2] )
  result = s.run()
  runcount = 0
  passcount = 0
  for t in result:
    runcount = runcount + 1
    if not t.passed:
      print t.testname + " : FAILED"
      print >> sys.stderr, t.mesg
      if( t.stderr!="" ): 
        print >> sys.stderr, t.stderr
      if( t.stdout!="" ): 
        print >> sys.stderr, t.stdout
    else:
      print t.testname + " : OK"
      passcount = passcount + 1
  if runcount==passcount:
    exit(0)
  exit(1)


def runSuiteOfTests():
  if len(sys.argv)!=3:
    print >> sys.stderr, "saru-run-test : suite mode expects one additional argument"
    exit(1)
  suitepath = sys.argv[2]
  if ( not os.path.isdir(suitepath ) ):
    print >> sys.stderr, os.path.basename( sys.argv[0] )+" : requires a directory name."
    exit(1)


  try:
    logs = [ os.path.basename(x) for x in glob.glob( os.path.normpath(suitepath+"/saru*.log" ) ) ]
    if len( logs )>0:
      last_log = max( [ int(re.search("saru(\d+).log",x).group(1)) for x in logs ] )
    else:
      last_log = -1
    logfile = open( os.path.normpath(suitepath+("/saru%04d.log" % (last_log+1) ) ), "w" )
    logfile.write( datetime.datetime.now().ctime() +"\n" )
    logfile.flush()
  except IOError:
    logfile = None


  filelist = os.listdir(suitepath)
  filelist.sort()
  filelist = [ os.path.normpath(suitepath+"/"+x) for x in filelist ] 
  filelist = [ x for x in filelist if os.path.isfile(x) ]
  filelist = [ x for x in filelist if isSaru(x)[0] ]
  passcount = 0
  runcount = 0
  for f in filelist:
    s = SingleTestRunner( f )
    t_start = time.time()
    result = s.run()
    t_end = time.time()
    #TODO: At the moment the duration of all subtests is set to that of the parent test
    #    : We should provide some way for the parent to divide that time up....
    #    : And potentially report on the parent as a whole?
    for t in result:
      runcount = runcount + 1 
      print t.testname + " :",
      if not t.passed:
        if logfile:
          logfile.write( t.testname + " : FAIL : %f\n" % (t_end - t_start) )
          logfile.flush()
        if( t.stderr=="" and t.mesg.strip()=="saru-run-test : execution of test failed with error code 1"):
          print "FAILED"
        else:
          print "FAILED???"
          print "==MESSAGE==\n" + t.mesg
          if ( t.stdout.strip()!=""):
            print "==STDOUT==\n" + t.stdout.strip()
          if ( t.stderr.strip()!=""):
            print "==STDERR==\n" + t.stderr.strip()
          print
          print
      else:
        passcount  = passcount +1
        if logfile:
          logfile.write( t.testname + " : OK : %f\n" % (t_end - t_start) )
          logfile.flush()
        print "OK"
  
  print repr(passcount) + " / " + repr( runcount) 
  try:
    f = open( os.path.normpath(suitepath+"/saru.progress" ), "a" )
    print >> f, datetime.datetime.now().isoformat(),
    print >> f, " "+str(passcount)+" "+str( runcount )
  except IOError:
    print "Unable to write results to log file"

  if( passcount == runcount ):
    exit(0)
  exit(1)



def runTaggedTests():
  tagname = sys.argv[2]
  tagpath = sys.argv[3]
  if ( not os.path.isdir(tagpath ) ):
    print >> sys.stderr, os.path.basename( sys.argv[0] )+" : requires a directory name."
    exit(1)

  tagProcess = subprocess.Popen( [ sarupath.sarusearch, "tag", tagname, tagpath ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
  (tagstdout,tagstderr) = tagProcess.communicate()
  retcode = tagProcess.returncode
  if(retcode!=0):
    print "saru-run-test : saru-search failed with value " + repr(recode)
    print "  STDOUT :" + tagstdout
    print "  STDERR :" + tagstderr 
  
  filelist = tagstdout .splitlines()
#  filelist = [ os.path.normpath(tagpath+"/"+x) for x in filelist ] 

  passcount = 0
  runcount = 0
  for f in filelist:
    s = SingleTestRunner( f )
    result = s.run()
    for t in result:
      runcount = runcount + 1 
      print t.testname + " :",
      if not t.passed:
        if( t.stderr=="" and t.mesg.strip()=="saru-run-test : execution of test failed with error code 1"):
          print "FAILED"
        else:
          print "FAILED???"
          print "==MESSAGE==\n" + t.mesg
          if ( t.stdout.strip()!=""):
            print "==STDOUT==\n" + t.stdout.strip()
          if ( t.stderr.strip()!=""):
            print "==STDERR==\n" + t.stderr.strip()
          print
          print
      else:
        passcount  = passcount +1
        print "OK"
  
  print repr(passcount) + " / " + repr( runcount) 
  if( passcount == runcount ):
    exit(0)
  exit(1)



if (len(sys.argv) < 2):
  printUsage()
  exit(1) 

if ( sys.argv[1] == "single" ):
  runSingleTest()
elif ( sys.argv[1] == "suite" ):
  runSuiteOfTests()
elif (sys.argv[1] == "tag" ):
  runTaggedTests()

print >> sys.stderr,"saru-run-test : Unknown mode "+sys.argv[1]
printUsage()
exit(1)

# vim: set sw=2 ts=2 expandtab : 

